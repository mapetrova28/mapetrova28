import os

pathname = raw_input("Enter a path to a folder: ")


def collect_text_files(directory):
    """Returns a list of pathnames for all *.txt files inside a given directory."""
    text_files = []
    for root, dirs, files in os.walk(directory):
        for name in files:
            if name.endswith(".txt"):
                path = os.path.join(root, name)
                text_files.append(path)
    return text_files


def analyze_text_file(path):
    """Analyzes a text file located on a given path
    and prints formatted aggregate statistics to console.
    """
    text_file = open(path, "r")
    all_lines = text_file.readlines()

    print(os.linesep + "=== Analyzing " + path + " ===" + os.linesep)

    results = []

    for curLine in all_lines:
        result = analyze_text_line(curLine.rstrip("\r\n"))
        results.append(result)

    header = ('Line #', 'Longest word', 'Shortest word', 'Line length', 'Average word length')
    col_lenghts = dict(zip((0, 1, 2, 3, 4), (len(str(x)) for x in header)))

    line_format = ' | '.join('%%-%ss' % col_lenghts[i] for i in xrange(0, 5))

    print os.linesep.join((line_format % header,
                           '-|-'.join(col_lenghts[i] * '-' for i in xrange(5)),
                           os.linesep.join(line_format % (i + 1, a, b, c, d) for i, (a, b, c, d) in enumerate(results))
                           ))
    print(os.linesep)


def analyze_text_line(line):
    """
    Analyzes a given text line and returns calculated statistics for it.
    :param line: A text line to analyze (stripped from line end characters).
    :return: A tuple consisting of (<longest word>, <shortest word>, <line length>, <average word length>)
            for a given line. Returns (0, 0, 0, 0) for an empty line.
    """
    i = 0
    original_line = line

    # Search through a given line for places with 3 consequent whitespaces.
    while i < len(line):
        i = line.find("   ")
        if i == -1:
            break

        # Calculate count of consequent whitespaces.
        white_count = 0

        for k in range(i, len(line)):
            if line[k] == " ":
                white_count += 1
            else:
                break

        replcmnt = prepare_replacement(white_count)

        # Replace a like like "   " (i.e. 3 consequent whitespaces) with " a "
        # or "    " (4 consequent whitespaces) with " aa "
        # etc...
        line = line.replace(" " * white_count, replcmnt, 1)

    splitted_line = line.split()

    # Get a list of lengths of all words for a given line.
    lengths = [len(word) for word in splitted_line]

    if len(lengths) > 0:
        # Calculate an average word length for a given line.
        average = sum(lengths) / len(lengths)
    else:
        average = 0

    if len(lengths) > 0:
        return max(lengths), min(lengths), len(original_line), average
    else:
        return 0, 0, 0, 0


def prepare_replacement(whitespace_count):
    """
    Prepares a "replacement string" for a given amount of whitespace characters.
    Examples:
        if origin_count == 3, it returns " a "
        if origin_count == 4, it returns " aa "
        if origin_count == 5, it returns " aaa "
        etc...
    :param orig_count: An amount of whitespace characters to prepare a "replacement sting" for.
    :return: A prepared replacement sting, like " aaa ".
    """
    result = " " * whitespace_count
    str_list = list(result)

    # Insert 'a' to the middle of the whitespace fragment.
    for i in range(1, whitespace_count - 1):
        str_list[i] = "a"

    return ''.join(str_list)


if not os.path.isdir(pathname):
    print("Given string is not a directory.")
    exit()

all_text_files = collect_text_files(pathname)

for cur_file in all_text_files:
    analyze_text_file(cur_file)
